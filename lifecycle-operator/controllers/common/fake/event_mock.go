// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package fake

import (
	apicommon "github.com/keptn/lifecycle-toolkit/lifecycle-operator/apis/lifecycle/v1alpha3/common"
	"sigs.k8s.io/controller-runtime/pkg/client"
	"sync"
)

// MockEvent is a mock implementation of common.IEvent.
//
//	func TestSomethingThatUsesIEvent(t *testing.T) {
//
//		// make and configure a mocked common.IEvent
//		mockedIEvent := &MockEvent{
//			EmitFunc: func(phase apicommon.KeptnPhaseType, eventType string, reconcileObject client.Object, status string, message string, version string)  {
//				panic("mock out the Emit method")
//			},
//		}
//
//		// use mockedIEvent in code that requires common.IEvent
//		// and then make assertions.
//
//	}
type MockEvent struct {
	// EmitFunc mocks the Emit method.
	EmitFunc func(phase apicommon.KeptnPhaseType, eventType string, reconcileObject client.Object, status string, message string, version string)

	// calls tracks calls to the methods.
	calls struct {
		// Emit holds details about calls to the Emit method.
		Emit []struct {
			// Phase is the phase argument value.
			Phase apicommon.KeptnPhaseType
			// EventType is the eventType argument value.
			EventType string
			// ReconcileObject is the reconcileObject argument value.
			ReconcileObject client.Object
			// Status is the status argument value.
			Status string
			// Message is the message argument value.
			Message string
			// Version is the version argument value.
			Version string
		}
	}
	lockEmit sync.RWMutex
}

// Emit calls EmitFunc.
func (mock *MockEvent) Emit(phase apicommon.KeptnPhaseType, eventType string, reconcileObject client.Object, status string, message string, version string) {
	if mock.EmitFunc == nil {
		panic("MockEvent.EmitFunc: method is nil but IEvent.Emit was just called")
	}
	callInfo := struct {
		Phase           apicommon.KeptnPhaseType
		EventType       string
		ReconcileObject client.Object
		Status          string
		Message         string
		Version         string
	}{
		Phase:           phase,
		EventType:       eventType,
		ReconcileObject: reconcileObject,
		Status:          status,
		Message:         message,
		Version:         version,
	}
	mock.lockEmit.Lock()
	mock.calls.Emit = append(mock.calls.Emit, callInfo)
	mock.lockEmit.Unlock()
	mock.EmitFunc(phase, eventType, reconcileObject, status, message, version)
}

// EmitCalls gets all the calls that were made to Emit.
// Check the length with:
//
//	len(mockedIEvent.EmitCalls())
func (mock *MockEvent) EmitCalls() []struct {
	Phase           apicommon.KeptnPhaseType
	EventType       string
	ReconcileObject client.Object
	Status          string
	Message         string
	Version         string
} {
	var calls []struct {
		Phase           apicommon.KeptnPhaseType
		EventType       string
		ReconcileObject client.Object
		Status          string
		Message         string
		Version         string
	}
	mock.lockEmit.RLock()
	calls = mock.calls.Emit
	mock.lockEmit.RUnlock()
	return calls
}
